#!/usr/bin/env python 
# -*- coding: utf-8 -*- 
# @Author: uu    
# @Date: 2024-12-12 09:50:08    
# @Last Modified by:   uu    
# @Last Modified time: 2024-12-12 09:50:08 




import os
import dash
import requests
from flask import request, send_from_directory, abort
# from config import PathConfig, DatabaseConfig

app = dash.Dash(
    __name__,
    suppress_callback_exceptions=True,
    serve_locally=True,
    update_title=None,
    compress=True,

    # routes_pathname_prefix='/dash/'
    # external_scripts=['D:\pyproject\pyecharts-assets']
)
app.title = 'BillSystem'
server = app.server


# 配置密钥
app.server.secret_key = 'Dash-Bill-Web-System'
app.server.config['COMPRESS_ALGORITHM'] = 'br'
app.server.config['COMPRESS_BR_LEVEL'] = 11

@app.server.before_request
def ban_sourcemap():
    if '.js.map' in request.url:
        return abort(403)


# # 获取用户浏览器信息
# @server.before_request
# def get_user_agent_info():
#     request_addr = request.headers.get("X-Forwarded-For")
#     user_string = str(request.user_agent)
#     # user_agent = parse(user_string)
#     # bw = user_agent.browser.family
#     print(request_addr, user_string)
#     # print(request.url)



#
# # 这里的app即为Dash实例
# @app.server.route('/upload/', methods=['POST'])
# def upload():
#     ''' 构建文件上传服务'''
#
#     # 获取上传id参数，用于指向保存路径
#     uploadId = request.values.get('uploadId')
#
#     # 获取上传的文件名称
#     filename = request.files['file'].filename
#
#     # 基于上传id，若本地不存在则会自动创建目录
#     try:
#         os.mkdir(os.path.join(PathConfig.PATH_CACHE, uploadId))
#     except FileExistsError:
#         pass
#
#
#     # 流式写出文件到指定目录
#     with open(os.path.join(PathConfig.PATH_CACHE, uploadId, filename), 'wb') as f:
#         # 流式写出大型文件，这里的10代表10MB
#         for chunk in iter(lambda: request.files['file'].read(1024 * 1024 * 10), b''):
#             f.write(chunk)
#
#     return {'filename': filename}
#
#
# @app.server.route('/download/<file>')
# def download(file):
#     return send_from_directory(PathConfig.PATH_CACHE, file)
#
#
# # This hook ensures that a connection is opened to handle any queries
# # generated by the request.
# @server.before_request
# def _db_connect():
#     for db in DatabaseConfig.MYSQL_DATABASES:
#         if not db.is_connection_usable():
#             db.connect()
#
#
# # This hook ensures that the connection is closed when we've finished
# # processing the request.
# @server.teardown_request
# def _db_close(exc):
#     for db in DatabaseConfig.MYSQL_DATABASES:
#         if not db.is_closed():
#             db.close()
#
#
#
#













